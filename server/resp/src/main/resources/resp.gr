// RESP 3.x protocol
namespace resp3x;

// Target class
class org.infinispan.server.resp.RespDecoder extends ByteToMessageDecoder;

// static final field values are literals

// methods simpleString, bulkString, byteArray, byte...
intrinsics org.infinispan.server.resp.Intrinsics;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import io.netty.handler.codec.ByteToMessageDecoder;
import org.infinispan.commons.logging.LogFactory;

init {
   protected final static Log log = LogFactory.getLog(RespDecoder.class, Log.class);
   protected final Resp2LongProcessor longProcessor = new Resp2LongProcessor();
   protected final RespRequestHandler requestHandler;
   private boolean disabledRead = false;

   public RespDecoder(RespRequestHandler initialHandler) {
      this.requestHandler = initialHandler;
   }

   /**
    * We usually know the size of the map ahead, and we want to return static empty map if we're not going to add anything.
    */
   protected static <K, V> Map<K, V> allocMap(int size) {
      return size == 0 ? Collections.emptyMap() : new HashMap<>(size * 4/3, 0.75f);
   }

   protected static <T> List<T> allocList(int size) {
      return size == 0 ? Collections.emptyList() : new ArrayList<>(size);
   }

   protected static <T> Set<T> allocSet(int size) {
      return size == 0 ? Collections.emptySet() : new HashSet<>(size);
   }

   @Override
   public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
      super.channelUnregistered(ctx);
      requestHandler.handleChannelDisconnect(ctx);
   }
}

exceptionally {
   log.trace("Parsing error", t);
   commandProcessor.writeException(getHeader(), t);
   state = 0;
}

// this is the root
root request
   : type
     command
     arguments { requestHandler = requestHandler.handleRequest(command, arguments) }
   ;

header returns GingersnapHeader
   : { magic != MAGIC_REQ }? { throw new InvalidMagicIdException("Error reading magic byte or message id: " + magic); }
   | messageId version operation cacheName flags intelligence topologyId keyType valueType otherParams
    { new GingersnapHeader(operation, version, messageId, cacheName, flags, intelligence, topologyId, keyType, valueType, otherParams) }
;

type: byte;
command returns String switch type
   : { SIMPLE_STRING }? simpleString
   : { BULK_STRING }? bulkString[longProcessor]
arguments:

execute
   : { SIMPLE_STRING }? arguments { requestHandler = requestHandler.handleRequest(command, arguments) }
   | { GET_REQUEST }? key { commandProcessor.get(getHeader(), key) }
   | { REMOVE_REQUEST }? key { commandProcessor.remove(getHeader(), key) }
   | { STATS_REQUEST }? { commandProcessor.stats(getHeader()) }
   | { PING_REQUEST }? { commandProcessor.ping(getHeader()); }
   | { QUERY_REQUEST }? queryBytes { commandProcessor.query(getHeader(), queryBytes); }
   | { EXEC_REQUEST }? taskName taskParams { commandProcessor.exec(getHeader(), taskName, taskParams); }
   | { PUT_ALL_REQUEST }? ignoreExpiration entryMap { commandProcessor.putAll(getHeader(), entryMap) }
   | { GET_ALL_REQUEST }? keys { commandProcessor.getAll(getHeader(), keys) }
   | { ITERATION_START_REQUEST }? segmentMask filterConverterFactory filterConverterParams batchSize includeMetadata
      { commandProcessor.iterationStart(getHeader(), segmentMask, filterConverterFactory, filterConverterParams, batchSize, includeMetadata); }
   | { ITERATION_NEXT_REQUEST }? iterationId { commandProcessor.iterationNext(getHeader(), iterationId); }
   | { ITERATION_END_REQUEST }? iterationId { commandProcessor.iterationEnd(getHeader(), iterationId); }

// Multimap
   | { GET_MULTIMAP_REQUEST }? key supportsDuplicates { if (!supportsDuplicates) throw new UnsupportedOperationException("Gingersnap only supports duplicates for multimap");
   commandProcessor.getMultiMap(getHeader(), key); }
   | { PUT_MULTIMAP_REQUEST }? key ignoreExpiration value supportsDuplicates { if (!supportsDuplicates) throw new UnsupportedOperationException("Gingersnap only supports duplicates for multimap");
   commandProcessor.putMultiMap(getHeader(), key, value); }

// Unknown
   | { throw new HotRodUnknownOperationException("Unknown operation " + opCode, version, messageId); }
   ;